#include <Arduino.h>
//#include "IoT.h"
#include <iostream>
#include <map>
#include <string>
#include <vector>
#include <iostream>

WiFiClient client;
PubSubClient MQTTClient;

extern std::string mqtt_server;
extern std::string mqtt_user;
extern std::string mqtt_password;
extern std::string mqtt_client;

QueueHandle_t MQTT_Publish_Queue;

struct MessageToPublish
{
  char topic[100];
  char payload[100];
};

TaskHandle_t MQTTTask;
TaskHandle_t MQTTClientTask;

volatile bool ConnectSubscriptions = false;

std::vector<std::string> SubscribedTopics;
std::vector<std::string> UnsubscribedTopics;

void MQTT_setup()
{
  MQTT_Publish_Queue = xQueueCreate(50, sizeof(MessageToPublish));

  xTaskCreatePinnedToCore(
      MQTT_task,          /* Task function. */
      "MQTT Task",        /* name of task. */
      17000,              /* Stack size of task (uxTaskGetStackHighWaterMark:16084) */
      NULL,               /* parameter of the task */
      MQTT_task_Priority, /* priority of the task */
      &MQTTTask,          /* Task handle to keep track of created task */
      1);

  xTaskCreatePinnedToCore(
      MQTT_Publish_task,         /* Task function. */
      "MQTT Client Task",        /* name of task. */
      17000,                     /* Stack size of task (uxTaskGetStackHighWaterMark:16084) */
      NULL,                      /* parameter of the task */
      MQTT_client_task_Priority, /* priority of the task */
      &MQTTClientTask,           /* Task handle to keep track of created task */
      1);
}

void Wifi_connect()
{
  Serial.println(F("Connecting to Wifi"));

  Wifi_setup();

  while (WiFi.status() != WL_CONNECTED)
  {
    Serial.println(WiFi.status());

    delay(100);
  }
}

void recieveMessage(char *topic, byte *payload, unsigned int length)
{
  Serial << "Message arrived [" << topic << "]" << endl;

  std::string receivedMsg;

  for (int i = 0; i < length; i++)
  {
    char c = payload[i];

    //Serial.print(c);

    receivedMsg += c;
  }
  //Serial.println();

  char msgtosend[MAXBBCMESSAGELENGTH];
  sprintf(msgtosend, "MQTT,'%s','%s'", topic, receivedMsg.c_str());
  sendToMicrobit(msgtosend);
}

void checkMQTTconnection()
{
  if (MQTTClient.connected() == false)
  {
    Serial.println(F("MQTTClient NOT Connected :("));

    delay(500);

    MQTTClient.connect(mqtt_client.c_str(), mqtt_user.c_str(), mqtt_password.c_str());

    //set to true to get the subscriptions setup again
    ConnectSubscriptions = true;
  }
}

void setupSubscriptions()
{
  for (std::string &e : SubscribedTopics)
  {
    Serial.print(F("subscribing to:"));
    Serial.println(e.c_str());

    MQTTClient.subscribe(e.c_str());
  }

  for (std::string &e : UnsubscribedTopics)
  {
    Serial.print(F("unsubscribing to:"));
    Serial.println(e.c_str());

    MQTTClient.unsubscribe(e.c_str());
  }
}

void MQTT_Publish_task(void *pvParameter)
{
  Serial << "waiting for wifi" << endl;

  while (WiFi.isConnected() == false)
  {
    Serial << ".";

    delay(1000);
  }

  Serial << "XXX" << endl;

  //set this up as early as possible
  MQTTClient.setClient(client);
  MQTTClient.setServer(mqtt_server.c_str(), 1883);
  MQTTClient.setCallback(recieveMessage);

  Serial << "@" << mqtt_server.c_str() << endl;

  for (;;)
  {
    if (WiFi.isConnected() == false)
    {
      Serial.println("WiFi.isConnected() == false");

      Wifi_connect();
    }
    else
    {
      if (MQTTClient.connected() == false)
      {
        Serial.println("checkMQTTconnection");

        checkMQTTconnection();
      }
      else
      {
        //check to see if we need to remake the subscriptions
        if (ConnectSubscriptions == true)
        {
          Serial.println("ConnectSubscriptions == true");

          //set up subscription topics
          setupSubscriptions();

          ConnectSubscriptions = false;
        }

        MessageToPublish msg;

        //check the message queue and if empty just proceed passed
        if (xQueueReceive(MQTT_Publish_Queue, &msg, 0) == pdTRUE)
        {
          Serial.print("publish topic:");
          Serial.print(msg.topic);
          Serial.print("\t\t");
          Serial.print("payload:");
          Serial.print(msg.payload);
          Serial.println("");

          MQTTClient.publish(msg.topic, msg.payload);
        }

        Serial.println("MQTTClient.loop()");

        //must always call the loop method - if we have wifi and a connection
        MQTTClient.loop();
      }

      delay(100);
    }
  }
  vTaskDelete(NULL);
}

void MQTT_task(void *pvParameter)
{
  // UBaseType_t uxHighWaterMark;
  // uxHighWaterMark = uxTaskGetStackHighWaterMark(NULL);
  // Serial.print("MQTT_task uxTaskGetStackHighWaterMark:");
  // Serial.println(uxHighWaterMark);

  for (;;)
  {
    messageParts parts;

    //wait for new MQTT command in the queue
    xQueueReceive(MQTT_Queue, &parts, portMAX_DELAY);

    Serial.print("MQTT_Queue:");
    Serial.println(parts.identifier);

    std::string identifier = parts.identifier;

    if (identifier.compare("PUBLISH") == 0)
    {
      struct MessageToPublish msg;
      strcpy(msg.topic, parts.part1);
      strcpy(msg.payload, parts.part2);

      Serial.print("queue message:");
      Serial.print(msg.topic);
      Serial.print("\t\t");
      Serial.print("payload:");
      Serial.print(msg.payload);
      Serial.println("");

      xQueueSend(MQTT_Publish_Queue, &msg, portMAX_DELAY);
    }
    else if (identifier.compare("SUBSCRIBE") == 0)
    {
      std::string topic(parts.part1);

      subscribe(topic);
    }
    else if (identifier.compare("UNSUBSCRIBE") == 0)
    {
      std::string topic(parts.part1);

      unsubscribe(topic);
    }
  }

  vTaskDelete(NULL);
}

void unsubscribe(std::string topic)
{
  UnsubscribedTopics.push_back(topic);

  //set to true to get the subscriptions setup again
  ConnectSubscriptions = true;
}

void subscribe(std::string topic)
{
  SubscribedTopics.push_back(topic);

  //set to true to get the subscriptions setup again
  ConnectSubscriptions = true;
}